import { LogUtil } from '@pura/harmony-utils'
import { BaseFocusDefinition } from 'api'
import { ClockData, EventData, FocusDataUtil, FocusPreferenceName } from '../utils/FocusDataUtil'
import { TimeUtil } from '../utils/TimeUtil'

/**
 * ç•ªèŒ„é’ŸViewModel - è´Ÿè´£æ‰€æœ‰ä¸šåŠ¡é€»è¾‘
 * 
 * èŒè´£:
 * - ç®¡ç†å€’è®¡æ—¶çŠ¶æ€(å½“å‰æ®µã€å·²ç”¨æ—¶é—´ç­‰)
 * - æ§åˆ¶å®šæ—¶å™¨çš„å¯åŠ¨ã€æš‚åœã€æ¢å¤
 * - å¤„ç†æ®µå®Œæˆã€å…¨éƒ¨å®Œæˆç­‰äº‹ä»¶
 * - æä¾›çŠ¶æ€ç»™UIç»„ä»¶
 * 
 * @author kedongjun
 * @since 2025-01-27
 */
export class TomatoClockViewModel {
  // ============ é…ç½®å‚æ•° ============
  public tomatoNum: number = 4
  public tomatoDuration: number = 30
  public tomatoModel: number = 30
  public isAutoRested: boolean = false
  public isStrict: boolean = false
  public title: string = ''
  public restDuration: number = 0
  public startTimestamp: number = 0

  // ============ çŠ¶æ€æ•°æ® ============
  public currentTomato: number = 0
  public currentTomatoSeconds: number = 0
  public useTime: number = 0
  public isPaused: boolean = false
  public isTipRest: boolean = false
  public isResting: boolean = false  // ğŸ†• æ˜¯å¦æ­£åœ¨ä¼‘æ¯ï¼ˆç”¨äºæ¢å¤çŠ¶æ€åˆ¤æ–­ï¼‰
  public currentRestSeconds: number = 0
  public currentRest: number = 0
  public isDone: boolean = false
  public isExtension: boolean = false

  // ============ å®šæ—¶å™¨ç®¡ç† ============
  private timerId: number = -1
  private lastTimestamp: number = 0
  private segmentStartTime: number = 0
  private readonly TICK_INTERVAL = 200
  
  // ============ å›è°ƒå‡½æ•° ============
  private onSegmentCompleteCallback?: (currentTomato: number, total: number) => void
  private onAllCompleteCallback?: () => void
  private onStateChangeCallback?: () => void

  // ============ æäº¤ç»™æœåŠ¡ç«¯çš„æ•°æ® ============
  private focusInput: BaseFocusDefinition.FocusRecordInputV2 = {
    endTime: TimeUtil.getCurrentTimeFormatted(),
    focusType: 3,
    fullTime: 0,
    startTime: TimeUtil.formatDateToStr(new Date(this.startTimestamp)),
    title: 'ç•ªèŒ„é’Ÿæµ‹è¯•',
    useTime: Math.floor(this.currentTomatoSeconds / 60),
    focusNum: this.tomatoNum,
    eventList: [],
    musicName: 'é»˜è®¤',
  }
  
  public onSegmentComplete(callback: (currentTomato: number, total: number) => void) {
    this.onSegmentCompleteCallback = callback
  }
  
  public onAllComplete(callback: () => void) {
    this.onAllCompleteCallback = callback
  }
  
  public onStateChange(callback: () => void) {
    this.onStateChangeCallback = callback
  }
  
  private notifyStateChange() {
    this.onStateChangeCallback?.()
  }
  
  /**
   * å¼€å§‹å€’è®¡æ—¶
   */
  public start(): void {
    if (this.timerId !== -1 || this.isDone) {
      LogUtil.debug('ç•ªèŒ„é’Ÿ: å·²åœ¨è¿è¡Œæˆ–å·²å®Œæˆ,æ— æ³•å¯åŠ¨')
      return
    }
    
    LogUtil.debug('ç•ªèŒ„é’Ÿ: å¼€å§‹å€’è®¡æ—¶')
    this.isPaused = false
    this.lastTimestamp = Date.now()
    
    if (this.segmentStartTime === 0) {
      this.segmentStartTime = Date.now()
    }
    
    // ğŸ†• å¦‚æœæ˜¯ç¬¬ä¸€ä¸ªç•ªèŒ„,è®°å½•"å¼€å§‹ç¬¬1ä¸ªç•ªèŒ„"äº‹ä»¶
    if (this.currentTomato === 0 && this.currentTomatoSeconds === 0) {
      this.addFocusEvent(4, `å¼€å§‹ç¬¬${this.currentTomato + 1}ä¸ªç•ªèŒ„`, 0)
    }
    
    this.timerId = setInterval(() => {
      this.tick()
    }, this.TICK_INTERVAL)
  }
  
  private tick(): void {
    const now = Date.now()
    
    if (this.isPaused || this.isDone) {
      this.lastTimestamp = now
      return
    }
    
    const realElapsedTime = (now - this.segmentStartTime) / 1000
    const deltaSeconds = (now - this.lastTimestamp) / 1000
    if (deltaSeconds > 0) {
      this.useTime += deltaSeconds
    }
    this.lastTimestamp = now
    this.currentTomatoSeconds = realElapsedTime
    
    if (this.currentTomatoSeconds >= this.tomatoDuration) {
      this.handleSegmentComplete()
    }
    
    this.notifyStateChange()
  }
  
  /**
   * å¤„ç†æ®µå®Œæˆ
   */
  private handleSegmentComplete(): void {
    this.currentTomato++
    this.currentTomatoSeconds = 0
    this.segmentStartTime = 0
    
    LogUtil.debug(`ç•ªèŒ„é’Ÿ: å®Œæˆç¬¬ ${this.currentTomato} ä¸ªç•ªèŒ„`)
    
    // ğŸ†• è®°å½•"å®Œæˆç¬¬Nä¸ªç•ªèŒ„"äº‹ä»¶
    this.addFocusEvent(3, `å®Œæˆç¬¬${this.currentTomato}ä¸ªç•ªèŒ„`, this.tomatoDuration)
    
    this.onSegmentCompleteCallback?.(this.currentTomato, this.tomatoNum)
    this.isPaused = true
    this.lastTimestamp = Date.now()
    
    if (this.currentTomato >= this.tomatoNum) {
      this.handleAllComplete()
    }
  }
  
  /**
   * å¤„ç†å…¨éƒ¨å®Œæˆ
   */
  private handleAllComplete(): void {
    this.isDone = true
    this.isExtension = true  // ğŸ†• è¿›å…¥å»¶é•¿é˜¶æ®µ
    this.stop()
    
    LogUtil.debug('ç•ªèŒ„é’Ÿ: å…¨éƒ¨ç•ªèŒ„å®Œæˆ!')
    
    // ğŸ†• ä¿å­˜isDoneå’ŒisExtensionçŠ¶æ€åˆ°ç¼“å­˜
    this.saveClockData(Date.now())
    
    this.onAllCompleteCallback?.()
  }
  
  public pause(): void {
    if (this.isPaused || this.isDone) return
    
    LogUtil.debug('ç•ªèŒ„é’Ÿ: æš‚åœ')
    this.isPaused = true
    this.lastTimestamp = Date.now()
    
    // ğŸ†• è®°å½•"æš‚åœ"äº‹ä»¶
    this.addFocusEvent(1, 'æš‚åœ:', this.currentTomatoSeconds)
    
    this.notifyStateChange()
  }
  
  public resume(): void {
    if (!this.isPaused || this.isDone) return
    
    LogUtil.debug('ç•ªèŒ„é’Ÿ: æ¢å¤')
    this.isPaused = false
    this.lastTimestamp = Date.now()
    this.segmentStartTime = Date.now() - this.currentTomatoSeconds * 1000
    
    // ğŸ†• è®°å½•"ç»§ç»­"äº‹ä»¶
    this.addFocusEvent(2, 'ç»§ç»­', 0)
    
    if (this.timerId === -1) {
      this.start()
    }
    
    this.notifyStateChange()
  }
  
  public togglePause(): void {
    if (this.isPaused) {
      this.resume()
    } else {
      this.pause()
    }
  }
  
  public stop(): void {
    if (this.timerId !== -1) {
      clearInterval(this.timerId)
      this.timerId = -1
      LogUtil.debug('ç•ªèŒ„é’Ÿ: åœæ­¢å®šæ—¶å™¨')
    }
  }
  
  public reset(): void {
    LogUtil.debug('ç•ªèŒ„é’Ÿ: é‡ç½®')
    this.stop()
    
    this.currentTomato = 0
    this.currentTomatoSeconds = 0
    this.useTime = 0
    this.isDone = false
    this.isPaused = false
    this.isExtension = false
    this.segmentStartTime = 0
    
    this.notifyStateChange()
  }
  
  /**
   * å»¶é•¿ç•ªèŒ„æ•°é‡
   */
  public extend(count: number = 1): void {
    if (count <= 0) return
    
    LogUtil.debug(`ç•ªèŒ„é’Ÿ: å»¶é•¿ ${count} ä¸ªç•ªèŒ„`)
    this.tomatoNum += count
    this.isDone = false
    this.isExtension = false  // ğŸ†• é€€å‡ºå»¶é•¿é˜¶æ®µ
    
    // ğŸ†• è®°å½•"å»¶é•¿"äº‹ä»¶
    this.addFocusEvent(6, `å»¶é•¿${count}ä¸ªç•ªèŒ„`, 0)
    
    // ğŸ”§ ä¿®å¤ï¼šä¿å­˜ tomatoNum åˆ°ç¼“å­˜
    let clockData = FocusDataUtil.getClockData(FocusPreferenceName.Tomato)
    clockData.tomatoNum = this.tomatoNum
    clockData.isDone = false
    clockData.isExtension = false
    FocusDataUtil.saveClockData(FocusPreferenceName.Tomato, clockData)
    
    if (this.isPaused) {
      // ğŸ†• è®°å½•"å¼€å§‹æ–°ç•ªèŒ„"äº‹ä»¶
      this.addFocusEvent(4, `å¼€å§‹ç¬¬${this.currentTomato + 1}ä¸ªç•ªèŒ„`, 0)
      this.resume()
    }
    
    this.notifyStateChange()
  }

  /**
   * ğŸ†• å®Œæˆä»»åŠ¡(è¿”å›é¦–é¡µå‰è°ƒç”¨)
   */
  public finishTask(): void {
    LogUtil.debug('ç•ªèŒ„é’Ÿ: å®Œæˆä»»åŠ¡')
    this.stop()
    
    // æ¸…ç©ºç¼“å­˜æ•°æ®
    FocusDataUtil.clearData(FocusPreferenceName.Tomato)
  }

  /**
   * ğŸ†• ä»ç¼“å­˜æ¢å¤å¹¶ç»§ç»­è¿è¡Œï¼ˆè®¾ç½®æ­£ç¡®çš„å¼€å§‹æ—¶é—´ï¼‰
   * @param elapsedSeconds å·²ç»è¿‡çš„ç§’æ•°
   */
  public restoreAndContinue(elapsedSeconds: number): void {
    LogUtil.debug(`ç•ªèŒ„é’Ÿ: æ¢å¤å¹¶ç»§ç»­ï¼Œå·²ç”¨æ—¶${elapsedSeconds}ç§’`)
    
    // è®¾ç½®å½“å‰å·²ç”¨æ—¶é—´
    this.currentTomatoSeconds = elapsedSeconds
    
    // å…³é”®ï¼šè®¾ç½®æ®µå¼€å§‹æ—¶é—´ = ç°åœ¨ - å·²ç”¨æ—¶é—´
    this.segmentStartTime = Date.now() - elapsedSeconds * 1000
    
    // å¯åŠ¨å®šæ—¶å™¨
    this.start()
  }

  public restoreState(state: ClockData): void {
    this.tomatoNum = state.tomatoNum
    this.tomatoDuration = state.tomatoDuration
    this.currentTomato = state.currentTomato
    this.currentTomatoSeconds = state.currentTomatoSeconds
    this.useTime = state.useTime
    this.isPaused = state.isPaused
    this.isDone = state.isDone
    this.isExtension = state.isExtension
    
    this.notifyStateChange()
  }
  
  /**
   * æ£€æŸ¥å¹¶åŒæ­¥çŠ¶æ€(ç”¨äºäº®å±åæ ¡å‡†)
   */
  public checkAndSync(): boolean {
    if (this.timerId === -1 || this.isDone || this.isPaused) {
      return false
    }
    
    LogUtil.debug('ç•ªèŒ„é’Ÿ: äº®å±æ ¡å‡†æ£€æŸ¥')
    
    const now = Date.now()
    const realElapsedTime = (now - this.segmentStartTime) / 1000
    
    if (realElapsedTime >= this.tomatoDuration) {
      LogUtil.debug(`ç•ªèŒ„é’Ÿ: æ ¡å‡†å‘ç°åº”å®Œæˆç•ªèŒ„,elapsed=${realElapsedTime}ç§’`)
      
      this.currentTomatoSeconds = realElapsedTime
      this.handleSegmentComplete()
      this.notifyStateChange()
      
      return true
    }
    
    this.currentTomatoSeconds = realElapsedTime
    this.notifyStateChange()
    
    return false
  }
  
  public destroy(): void {
    this.stop()
    this.onSegmentCompleteCallback = undefined
    this.onAllCompleteCallback = undefined
    this.onStateChangeCallback = undefined
  }

  /**
   * ä¿å­˜ç•ªèŒ„é’Ÿäº‹ä»¶æ•°æ®å¿«ç…§
   */
  addFocusEvent(type: number, content: string, focusMinute: number, clockTimestamp?: number) {
    LogUtil.debug('ç•ªèŒ„é’Ÿ äº‹ä»¶æ•°æ®:addFocusEvent() type===' + type + ',content===' + content + ',focusMinute===' + focusMinute + ',clockTimestamp===' + clockTimestamp )
    let eventTime = clockTimestamp ? clockTimestamp : Date.now()

    let event: BaseFocusDefinition.FocusRecordEventInputV2 = {
      eventTime: TimeUtil.formatDateToStr(new Date(eventTime)),
      eventType: type,//äº‹ä»¶ç±»å‹ï¼š1-æš‚åœ 2-ç»§ç»­ 3-å®Œæˆç•ªèŒ„é’Ÿ 4-å¼€å§‹ç•ªèŒ„é’Ÿ 5-ä¼‘æ¯ 6-å»¶é•¿ 7-æ‰“å¼€ç¬¬ä¸‰æ–¹åº”ç”¨ 8-ä¼‘æ¯å®Œæˆ
      focusMinute: Math.floor(focusMinute / 60),
      content: content,
    }
    
    LogUtil.debug('ç•ªèŒ„é’Ÿ äº‹ä»¶æ•°æ®:this.focusInput.eventList ====' + JSON.stringify(this.focusInput.eventList))

    if (type === 1 && this.focusInput.eventList && this.focusInput.eventList.length > 0) {
      if (this.focusInput.eventList[this.focusInput.eventList.length -1].content === 'æš‚åœ:') {
        this.focusInput.eventList.pop();
        LogUtil.debug('ç•ªèŒ„é’Ÿ äº‹ä»¶æ•°æ®:pop å¦‚æœæœ€åä¸€æ¡å†…å®¹åªæœ‰"æš‚åœ:",åˆ™åˆ æ‰')
      }
    }

    this.focusInput.eventList?.push(event)

    LogUtil.debug('ç•ªèŒ„é’Ÿ äº‹ä»¶æ•°æ®:push ====' + JSON.stringify(event))
    LogUtil.debug('ç•ªèŒ„é’Ÿ äº‹ä»¶æ•°æ®:this.focusInput.eventList ====' + JSON.stringify(this.focusInput.eventList))

    let eventData: EventData = {
      eventList: this.focusInput.eventList
    }

    LogUtil.debug('ç•ªèŒ„é’Ÿ äº‹ä»¶æ•°æ®:data ====' + JSON.stringify(eventData))
    FocusDataUtil.saveEventData(FocusPreferenceName.Tomato, eventData)

    this.saveClockData(eventTime)
  }

  /**
   * åˆå§‹åŒ–ç•ªèŒ„é’Ÿæ•°æ®å¿«ç…§
   */
  initClockData() {
    let clockData: ClockData = FocusDataUtil.getClockData(FocusPreferenceName.Tomato)
    if (clockData.startTimestamp === 0) {
      clockData.startTimestamp = Date.now()
      clockData.tomatoNum = this.tomatoNum
      clockData.tomatoDuration = this.tomatoDuration
      clockData.tomatoModel = this.tomatoModel
      clockData.isAutoRested = this.isAutoRested
      clockData.isStrict = this.isStrict
      clockData.title = this.title
      clockData.restDuration = this.restDuration

      LogUtil.debug('ç•ªèŒ„é’Ÿ:initClockData() åˆå§‹åŒ–æ—¶é’Ÿæ•°æ® clockData===' + JSON.stringify(clockData))
      FocusDataUtil.saveClockData(FocusPreferenceName.Tomato, clockData)
    } else {
      LogUtil.debug('ç•ªèŒ„é’Ÿ:saveClockData() æ—¶é’Ÿæ•°æ®å·²å­˜åœ¨,ä¸éœ€è¦é‡å¤åˆå§‹åŒ–' )
    }
  }

  /**
   * ä¿å­˜ç•ªèŒ„é’Ÿæ•°æ®å¿«ç…§
   */
  saveClockData(eventTime: number) {
    let clockData: ClockData = FocusDataUtil.getClockData(FocusPreferenceName.Tomato)
    clockData.eventTimestamp = eventTime
    clockData.currentTomato = this.currentTomato
    clockData.isPaused = this.isPaused
    clockData.useTime = this.useTime
    clockData.currentTomatoSeconds = this.currentTomatoSeconds
    clockData.isTipRest = this.isTipRest
    clockData.isResting = this.isResting  // ä¿å­˜ä¼‘æ¯çŠ¶æ€
    clockData.currentRestSeconds = this.currentRestSeconds
    clockData.currentRest = this.currentRest
    clockData.isDone = this.isDone
    clockData.isExtension = this.isExtension

    LogUtil.debug('ç•ªèŒ„é’Ÿ:saveClockData() ä¿å­˜æ—¶é’Ÿæ•°æ® clockData===' + JSON.stringify(clockData))
    FocusDataUtil.saveClockData(FocusPreferenceName.Tomato, clockData)
  }

  public getClockData(): ClockData {
    const clockData: ClockData = FocusDataUtil.getClockData(FocusPreferenceName.Tomato)
    return clockData
  }
}
